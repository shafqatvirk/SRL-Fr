import os
def generate_zimple_program(sent):
	exclusionDict = buildExclusionDict()
	requireDict = buildRequirDict()
	
	inputFile = open(sent)
	frames = []
	roles = {}
	spans = {}
	frameLines = []
	while True:
		l = inputFile.readline()
		if not l: break
		if l.split(' ')[0] == 'Frame:':
			f = l.split(' ')[1].rstrip()
			frames.append(f)
			r = inputFile.readline()
			roles[f] = r.rstrip().split(' ')
			s = inputFile.readline()
			spans[f] = s.rstrip().split(' ')
	if not os.path.exists('../zimplCode/srl2.zpl'):
	   output_program_file = open('../zimplCode/srl2.zpl','w')
	else:
		output_program_file = open('../zimplCode/srl2.zpl','w')	
	fStr = "{"
	rStr = ''
	sStr = ''
	zStr = ''
	pStr = ''
	sumExprs = []
	uniqueStr = ''
	gStr = ''
	overlapStr = ''
	reqStr = ''
	excStr = ''
	for f in frames:
		fStr = fStr+'"'+f+'",'
		
	fStr = fStr.rstrip(',')+"};"
	output_program_file.write('# An autogenerated ZIMPL code to jointly map roles to spans for N number of frame in one sentence\n')
	output_program_file.write('set Frames := '+fStr+'\n')
	idx = 0
	sStr = sStr + '{"'+'","'.join(spans[frames[0]])+'"}'
	gStr = gStr + 'set G[I] := ' + buildSpanOverlapingSet(spans[frames[0]])
	for f in frames:
		rStr = rStr + ' <"'+f+'"> {"'+'","'.join(roles[f])+'"},'
		
		zStr = zStr + 'var z'+str(idx)+'[Assignment["'+f+'"]] binary;\n'
		pStr = pStr + 'param probabilities'+str(idx)+'[Assignment["'+f+'"]] := read "../frameData/frame'+str(idx)+'.txt" as "<1s,2s> 3n" skip 2;\n'
		sumExprs.append('sum <r,s> in Assignment["'+f+'"] : probabilities'+str(idx)+'[r,s] * z'+str(idx)+'[r,s]')
		uniqueStr = uniqueStr + 'subto unique'+str(idx)+ ': forall <r> in Roles["'+f+'"] do sum <s> in Spans : z'+str(idx)+'[r,s] == 1;\n'
		
		overlapStr = overlapStr + 'subto overlap' +str(idx)+ ': forall <i> in I do \n sum <r> in Roles["'+f+'"] do \n sum <s> in G[i] do z'+str(idx)+'[r,s] <= 1;\n'
		if requireDict.has_key(f):
			reqStr = reqStr + 'set Reqr' +str(idx)+ ' := ' + requireDict[f].rstrip() +';\n' + 'subto require' +str(idx)+ ': forall <ri,rj> in Reqr'+ str(idx)+' do z'+str(idx)+'[ri,"-1_-1"] - z'+str(idx)+'[rj,"-1_-1"] == 0;\n'
		if exclusionDict.has_key(f):
			excStr = excStr + 'set Exc' +str(idx)+ ' := ' + exclusionDict[f].rstrip() +';\n' + 'subto exclusion' +str(idx)+ ': forall <ri,rj> in Exc'+ str(idx)+' do z'+str(idx)+'[ri,"-1_-1"] + z'+str(idx)+'[rj,"-1_-1"] >= 1;\n'
		
		idx = idx + 1
		
	rStr = rStr.rstrip(',')+';\n'
	sStr = sStr.rstrip(',')+';\n'
	output_program_file.write('set Roles[Frames] := '+rStr)
	output_program_file.write('set Spans := '+sStr)
	output_program_file.write('set Assignment[<f> in Frames] := {Roles[f]*Spans};\n')
	output_program_file.write(zStr)
	output_program_file.write(pStr)
	output_program_file.write('\n #Objective Function \n')
	output_program_file.write('maximize assign : '+'+'.join(['('+ s + ')' for s in sumExprs])+';\n')
	output_program_file.write('#Constraints\n')
	output_program_file.write('#Overlap Constraints\n')
	output_program_file.write('set I := {0 to '+getLenSen(spans[frames[0]])+'};\n')

	output_program_file.write(gStr)
	output_program_file.write(overlapStr)
	output_program_file.write('#Uniqueness Constraint\n')
	output_program_file.write(uniqueStr)
	
	output_program_file.write('#pairwise exclusion constraint\n')
	output_program_file.write(excStr)	

	output_program_file.write('#pairwise requirement constraint\n')
	output_program_file.write(reqStr)
	
	output_program_file.close()
	print roles
	print spans
	

def getLenSen(spans):
	print spans
	N1 = []
	for s in spans:
		for i in s.split('_'):
			N1.append(int(i))
	return str(max(N1))

def buildSpanOverlapingSet(spans):
	N1 = []
	span_pairs = []
	for s in spans:
		span_pairs.append((int(s.split('_')[0]),int(s.split('_')[1])))
		for i in s.split('_'):
			N1.append(int(i))	
	
	minimum = min(N1)
	maximum = max(N1)
	N2 = range(0,maximum+1)
	G = []
	#print span_pairs
	for i in N2:
		#print i
		temp = []
		for (n,m) in span_pairs:
			
			if n <= i and m >=i:
				temp.append((n,m))
		G.append(temp)
		#print temp
	print G
	tempStr = ''
	idx = 0
	for a in G:
		tempStr = tempStr + '<'+str(idx)+'> {'
		tempStr2 = ''
		for (n,m) in a:
			tempStr2 = tempStr2+'"'+str(n)+'_'+str(m)+'",'
		tempStr2.rstrip(',')
		tempStr = tempStr + tempStr2.rstrip(',') + '}, '
		idx = idx + 1
	tempStr = tempStr.rstrip(' ').rstrip(',')+';\n'
	
	return tempStr
	#set I := {1 to 11};
	#set G1[I] := <1> {"0_0","0_10"}, <2> {"1_1","0_10"}, <3> {"2_2","0_10","2_3","2_9"}, <4> {"3_3","0_10","2_3","2_9"}, <5> {"4_4","0_10","2_9","4_9"}, <6> {"5_5","0_10","2_9","4_9","5_9"}, <7> {"6_6","0_10","2_9","4_9","5_9"}, <8> {"7_7","0_10","2_9","4_9","5_9"}, <9> {"8_8","0_10","2_9","4_9","5_9"}, <10> {"9_9","0_10","2_9","4_9","5_9"}, <11> {"10_10","0_10"};
	#set G[<i> in I] := {<n1,n2> in ((I cross N2) inter N)  with n1 <= i and n2 >= i};
def buildRequirDict():
	reqDict = {}
	reqData = open('../data/require.map').readlines()
	for f in reqData:
		reqDict[f.split('=')[0]] = f.split('=')[1]
	return reqDict
def buildExclusionDict():
	excDict = {}
	excData = open('../data/exclusion.map').readlines()
	for f in excData:
		excDict[f.split('=')[0]] = f.split('=')[1]
	return excDict
if __name__ == "__main__":
	import sys
	try:
		generate_zimple_program(sys.argv[1])
	except:
		print >>sys.stderr, __doc__
		raise